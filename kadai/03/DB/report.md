## 課題1: テーブル設計の正規化

### 1) 問題点の指摘

単一の「お気に入り」テーブルに `user_name` や `recipe_title` を保存している場合、以下の問題が生じる。

#### (1) 冗長性の問題
同じユーザー名やレシピ名が、複数行にわたって繰り返し保存される。
例えば、田中圭さんがお気に入り登録を3件している場合：

| user_name | recipe_title |
|----------|--------------|
| 田中圭    | 麻婆豆腐     |
| 田中圭    | カレー       |
| 田中圭    | パスタ       |

→ **同じデータを毎回保持するため無駄が大きい（冗長性が高い）**

#### (2) 一貫性の問題（更新異常）
冗長なデータが原因で、変更時に不整合が発生する。
例：田中圭さんが「田中 圭介」に改名したとき

全ての行を更新しなければならないが、1行でも更新漏れが起きると…

| user_name |
|----------|
| 田中 圭介  |
| 田中圭    | ← 更新漏れ…矛盾が発生

→ **データの一貫性が保てなくなる（更新異常）**

#### (3) 挿入異常
ユーザーを登録したいが、まだお気に入りが1件も無い場合…

| user_name | recipe_title |
|----------|--------------|
| ？       | （入れられない） |

→ **ユーザー単体のデータを格納できず、正しいデータが登録できない**

#### (4) 削除異常
田中圭さんが全てのお気に入りを削除すると、同時にユーザー情報も失われる：

| 削除後のテーブル |
|----------------|
| （空）        |

→ **存在するべきユーザー情報まで失われる（属性喪失 → 削除異常）**

---

### ▶ まとめ
| 問題 | 原因 |
|------|------|
| 冗長性 | 同じ情報を複数行に保存している |
| 一貫性の欠如 | 更新を複数行に対して行う必要があり漏れが起きる |
| 更新異常 | 名前変更時に全行を修正する必要がある |
| 挿入異常 | ユーザー単体を登録できない |
| 削除異常 | 最後の行を削除した際に他の重要情報まで失われる |

**→ これらを解決するために第3正規形へ分割する必要がある**

### 2) 第3正規形のテーブル定義（主キーは太字）
- **users**: **`user_id`**, `user_name`, `email`
- **recipes**: **`recipe_id`**, `title`, `category`
- **favorites**: **`user_id`**, **`recipe_id`**, `favorited_at`  
  - Primary Key: (**`user_id`**, **`recipe_id`**)  
  - Foreign Key: `user_id → users.user_id`, `recipe_id → recipes.recipe_id`

### 3) SQL: 田中 圭さんのお気に入りレシピのタイトル一覧
```sql
SELECT r.title
FROM users u
JOIN favorites f ON f.user_id = u.user_id
JOIN recipes   r ON r.recipe_id = f.recipe_id
WHERE u.user_name = '田中 圭'
ORDER BY f.favorited_at DESC;
```
---

## 課題2: 巨大ログテーブルのパフォーマンス改善

### 1) 遅い原因（推測）
- インデックス未設定で、条件 recipe_id=... AND access_timestamp BETWEEN ... が全表走査。
- ORDER BY access_timestamp DESC で大規模ソートが発生。

### 2) インデックス設計と理由
- 複合B+Treeインデックス：(recipe_id, access_timestamp)
- 等価条件→範囲条件の順でスキャン最小化 & ソート回避。
